// TC: O(n^2) 
// SC: O(n)

class Solution {
    
    int[] colors;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        
        int n = graph.length;
        
        colors = new int[n];
        Arrays.fill(colors,-1);
        int color = 0;
        
        for(int i=0;i<n;i++){
            if(colors[i]== -1){
                dfs(graph,i,color);
                color++;
            }
        }
        
        int[] groups = new int[color];
        
        //size of groups
        for(int i=0;i<n;i++){
            groups[colors[i]]++;
        }
        
        //no of infected nodes in groups
        int[] infected = new int[color];
        for(int i=0;i<initial.length;i++){
            infected[colors[initial[i]]]++;
        }
        
        //finding minnode
        int minNode = Integer.MAX_VALUE;
        int size = Integer.MIN_VALUE;
        
        for(int i=0;i<initial.length;i++){
            if(infected[colors[initial[i]]]!=1){
                
            }else if(size == Integer.MIN_VALUE){
                size=groups[colors[initial[i]]];
                minNode=initial[i];
            }else if(groups[colors[initial[i]]]>size){
                size=groups[colors[initial[i]]];
                minNode=initial[i];
            }else if(groups[colors[initial[i]]]==size){
                minNode=Math.min(minNode,initial[i]);
            }
        }
        
        if(size==Integer.MIN_VALUE){
            for(int i=0;i<initial.length;i++){
                minNode=Math.min(minNode,initial[i]);
            }
        }
        
        return minNode;
         
    }
    private void dfs(int[][] graph,int i,int color){
        // base case
        if(colors[i]!=-1) return;
        // logic
        colors[i]=color;
        for(int j=0;j<graph.length;j++){
            if(graph[i][j]==1){
                dfs(graph,j,color);
            }
        }
    }
}
